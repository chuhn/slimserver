From: Christopher Huhn <c.huhn@gsi.de>
Date: Sun, 2 Mar 2014 23:09:47 +0100
Subject: JSON::XS::VersionOneAndTwo totally obsolete

---
 Slim/Control/Commands.pm                      |    2 +-
 Slim/Control/Queries.pm                       |    2 +-
 Slim/Formats/XML.pm                           |    2 +-
 Slim/GUI/ControlPanel.pm                      |    2 +-
 Slim/Networking/Discovery/Players.pm          |    2 +-
 Slim/Networking/SqueezeNetwork.pm             |    2 +-
 Slim/Networking/SqueezeNetwork/Players.pm     |    2 +-
 Slim/Networking/SqueezeNetwork/PrefSync.pm    |    2 +-
 Slim/Networking/SqueezeNetwork/Stats.pm       |    2 +-
 Slim/Plugin/AudioScrobbler/Plugin.pm          |    2 +-
 Slim/Plugin/Classical/ProtocolHandler.pm      |    2 +-
 Slim/Plugin/Deezer/ProtocolHandler.pm         |    2 +-
 Slim/Plugin/Facebook/Plugin.pm                |  173 +++++++++
 Slim/Plugin/Flickr/Plugin.pm                  |    2 +-
 Slim/Plugin/ImageBrowser/Plugin.pm            |    2 +-
 Slim/Plugin/LastFM/Plugin.pm                  |    2 +-
 Slim/Plugin/LastFM/ProtocolHandler.pm         |    2 +-
 Slim/Plugin/Live365/ProtocolHandler.pm        |    2 +-
 Slim/Plugin/MOG/ProtocolHandler.pm            |    2 +-
 Slim/Plugin/Mediafly/ProtocolHandler.pm       |  468 +++++++++++++++++++++++++
 Slim/Plugin/Orange/Metadata.pm                |    2 +-
 Slim/Plugin/Pandora/ProtocolHandler.pm        |    2 +-
 Slim/Plugin/RhapsodyDirect/ProtocolHandler.pm |    2 +-
 Slim/Plugin/SN/ProtocolHandler.pm             |    2 +-
 Slim/Plugin/Sirius/ProtocolHandler.pm         |    2 +-
 Slim/Plugin/Slacker/ProtocolHandler.pm        |    2 +-
 Slim/Plugin/SpotifyLogi/ProtocolHandler.pm    |    2 +-
 Slim/Plugin/WiMP/ProtocolHandler.pm           |    2 +-
 Slim/Schema/TrackPersistent.pm                |    2 +-
 Slim/Utils/Prefs/Base.pm                      |    2 +-
 Slim/Utils/Progress.pm                        |    2 +-
 Slim/Utils/SQLiteHelper.pm                    |    2 +-
 Slim/Utils/Strings.pm                         |    2 +-
 Slim/Web/Cometd.pm                            |    2 +-
 Slim/Web/JSONRPC.pm                           |    2 +-
 35 files changed, 674 insertions(+), 33 deletions(-)
 create mode 100644 Slim/Plugin/Facebook/Plugin.pm
 create mode 100644 Slim/Plugin/Mediafly/ProtocolHandler.pm

diff --git a/Slim/Control/Commands.pm b/Slim/Control/Commands.pm
index 1eeacb3..f5c2311 100644
--- a/Slim/Control/Commands.pm
+++ b/Slim/Control/Commands.pm
@@ -32,7 +32,7 @@ use File::Spec::Functions qw(catfile);
 use File::Basename qw(basename);
 use Digest::MD5 qw(md5_hex);
 use Digest::SHA qw(sha1_base64);
-use JSON::XS::VersionOneAndTwo;
+use JSON;
 
 use Slim::Utils::Alarm;
 use Slim::Utils::Log;
diff --git a/Slim/Control/Queries.pm b/Slim/Control/Queries.pm
index b604d4d..3392776 100644
--- a/Slim/Control/Queries.pm
+++ b/Slim/Control/Queries.pm
@@ -32,7 +32,7 @@ L<Slim::Control::Queries> implements most Logitech Media Server queries and is d
 use strict;
 
 use Storable;
-use JSON::XS::VersionOneAndTwo;
+use JSON;
 use MIME::Base64 qw(encode_base64 decode_base64);
 use Scalar::Util qw(blessed);
 use URI::Escape;
diff --git a/Slim/Formats/XML.pm b/Slim/Formats/XML.pm
index a3bf362..ef5d855 100644
--- a/Slim/Formats/XML.pm
+++ b/Slim/Formats/XML.pm
@@ -13,7 +13,7 @@ package Slim::Formats::XML;
 use strict;
 use File::Slurp;
 use HTML::Entities;
-use JSON::XS::VersionOneAndTwo;
+use JSON;
 use Scalar::Util qw(weaken);
 use URI::Escape qw(uri_escape uri_escape_utf8);
 use XML::Simple;
diff --git a/Slim/GUI/ControlPanel.pm b/Slim/GUI/ControlPanel.pm
index 5feb1fd..d17c0ba 100644
--- a/Slim/GUI/ControlPanel.pm
+++ b/Slim/GUI/ControlPanel.pm
@@ -270,7 +270,7 @@ package Slim::GUI::ControlPanel;
 use base 'Wx::App';
 use Wx qw(:everything);
 use LWP::UserAgent;
-use JSON::XS::VersionOneAndTwo;
+use JSON;
 
 use Slim::Utils::ServiceManager;
 
diff --git a/Slim/Networking/Discovery/Players.pm b/Slim/Networking/Discovery/Players.pm
index b501822..7c010c6 100644
--- a/Slim/Networking/Discovery/Players.pm
+++ b/Slim/Networking/Discovery/Players.pm
@@ -11,7 +11,7 @@ package Slim::Networking::Discovery::Players;
 
 use strict;
 
-use JSON::XS::VersionOneAndTwo;
+use JSON;
 
 use Slim::Control::Request;
 use Slim::Networking::Discovery::Server;
diff --git a/Slim/Networking/SqueezeNetwork.pm b/Slim/Networking/SqueezeNetwork.pm
index 3b9f775..d891435 100644
--- a/Slim/Networking/SqueezeNetwork.pm
+++ b/Slim/Networking/SqueezeNetwork.pm
@@ -8,7 +8,7 @@ use strict;
 use base qw(Slim::Networking::SimpleAsyncHTTP);
 
 use Digest::SHA qw(sha1_base64);
-use JSON::XS::VersionOneAndTwo;
+use JSON;
 use MIME::Base64 qw(encode_base64);
 use URI::Escape qw(uri_escape);
 
diff --git a/Slim/Networking/SqueezeNetwork/Players.pm b/Slim/Networking/SqueezeNetwork/Players.pm
index addac57..8c1fd38 100644
--- a/Slim/Networking/SqueezeNetwork/Players.pm
+++ b/Slim/Networking/SqueezeNetwork/Players.pm
@@ -7,7 +7,7 @@ package Slim::Networking::SqueezeNetwork::Players;
 use strict;
 
 use Data::URIEncode qw(complex_to_query);
-use JSON::XS::VersionOneAndTwo;
+use JSON;
 
 use Slim::Control::Request;
 use Slim::Networking::SqueezeNetwork;
diff --git a/Slim/Networking/SqueezeNetwork/PrefSync.pm b/Slim/Networking/SqueezeNetwork/PrefSync.pm
index dd9e0a3..84572db 100644
--- a/Slim/Networking/SqueezeNetwork/PrefSync.pm
+++ b/Slim/Networking/SqueezeNetwork/PrefSync.pm
@@ -8,7 +8,7 @@ use strict;
 
 use File::Basename qw(basename dirname);
 use File::Spec::Functions qw(catfile);
-use JSON::XS::VersionOneAndTwo;
+use JSON;
 
 use Slim::Control::Request;
 use Slim::Hardware::IR;
diff --git a/Slim/Networking/SqueezeNetwork/Stats.pm b/Slim/Networking/SqueezeNetwork/Stats.pm
index 6a715e8..ab1c621 100644
--- a/Slim/Networking/SqueezeNetwork/Stats.pm
+++ b/Slim/Networking/SqueezeNetwork/Stats.pm
@@ -6,7 +6,7 @@ package Slim::Networking::SqueezeNetwork::Stats;
 
 use strict;
 
-use JSON::XS::VersionOneAndTwo;
+use JSON;
 
 use Slim::Control::Request;
 use Slim::Networking::SqueezeNetwork;
diff --git a/Slim/Plugin/AudioScrobbler/Plugin.pm b/Slim/Plugin/AudioScrobbler/Plugin.pm
index 8b108b4..a8a3d51 100644
--- a/Slim/Plugin/AudioScrobbler/Plugin.pm
+++ b/Slim/Plugin/AudioScrobbler/Plugin.pm
@@ -43,7 +43,7 @@ use Slim::Utils::Strings qw(string);
 use Slim::Utils::Timers;
 
 use Digest::MD5 qw(md5_hex);
-use JSON::XS::VersionOneAndTwo;
+use JSON;
 use URI::Escape qw(uri_escape_utf8 uri_unescape);
 
 my $prefs = preferences('plugin.audioscrobbler');
diff --git a/Slim/Plugin/Classical/ProtocolHandler.pm b/Slim/Plugin/Classical/ProtocolHandler.pm
index a6f1f73..4f07401 100644
--- a/Slim/Plugin/Classical/ProtocolHandler.pm
+++ b/Slim/Plugin/Classical/ProtocolHandler.pm
@@ -7,7 +7,7 @@ package Slim::Plugin::Classical::ProtocolHandler;
 use strict;
 use base qw(Slim::Player::Protocols::HTTP);
 
-use JSON::XS::VersionOneAndTwo;
+use JSON;
 use Scalar::Util qw(blessed);
 use URI::Escape qw(uri_escape_utf8);
 
diff --git a/Slim/Plugin/Deezer/ProtocolHandler.pm b/Slim/Plugin/Deezer/ProtocolHandler.pm
index e773b38..f7ff8a2 100644
--- a/Slim/Plugin/Deezer/ProtocolHandler.pm
+++ b/Slim/Plugin/Deezer/ProtocolHandler.pm
@@ -5,7 +5,7 @@ package Slim::Plugin::Deezer::ProtocolHandler;
 use strict;
 use base qw(Slim::Player::Protocols::HTTP);
 
-use JSON::XS::VersionOneAndTwo;
+use JSON;
 use URI::Escape qw(uri_escape_utf8);
 use Scalar::Util qw(blessed);
 
diff --git a/Slim/Plugin/Facebook/Plugin.pm b/Slim/Plugin/Facebook/Plugin.pm
new file mode 100644
index 0000000..3d65373
--- /dev/null
+++ b/Slim/Plugin/Facebook/Plugin.pm
@@ -0,0 +1,173 @@
+package Slim::Plugin::Facebook::Plugin;
+
+# $Id$
+
+use strict;
+use base qw(Slim::Plugin::OPMLBased);
+
+use JSON;
+use URI::Escape qw(uri_escape_utf8);
+
+use Slim::Networking::SqueezeNetwork;
+
+sub initPlugin {
+	my $class = shift;
+
+	$class->SUPER::initPlugin(
+		feed   => Slim::Networking::SqueezeNetwork->url( '/api/facebook/v1/opml' ),
+		tag    => 'facebook',
+		is_app => 1,
+	);
+	
+	# Track Info item
+	Slim::Menu::TrackInfo->registerInfoProvider( facebook => (
+		after => 'middle',
+		func  => \&trackInfoMenu,
+	) );
+}
+
+# Don't add this item to any menu
+sub playerMenu { }
+
+sub initCLI {
+	my ( $class, %args ) = @_;
+	
+	$class->SUPER::initCLI( %args );
+	
+	# Facebook defines 2 SP screensavers:
+	# My Facebook News Feed
+	# My Facebook photos
+	
+	Slim::Control::Request::addDispatch(
+		[ $args{tag}, 'screensaver_news' ],
+		[ 1, 1, 1, \&screensaver_news ]
+	);
+	
+	Slim::Control::Request::addDispatch(
+		[ $args{tag}, 'screensaver_photos' ],
+		[ 1, 1, 1, \&screensaver_photos ]
+	);
+}
+
+# Extend initJive to setup screensavers
+sub initJive {
+	my ( $class, %args ) = @_;
+	
+	my $menu = $class->SUPER::initJive( %args );
+	
+	return if !$menu;
+	
+	$menu->[0]->{screensavers} = [
+		{
+			cmd         => [ $args{tag}, 'screensaver_news' ],
+			stringToken => 'PLUGIN_FACEBOOK_SCREENSAVER_NEWS',
+		},
+		{
+			cmd         => [ $args{tag}, 'screensaver_photos' ],
+			stringToken => 'PLUGIN_FACEBOOK_SCREENSAVER_PHOTOS',
+		},
+	];
+	
+	return $menu;
+}			
+
+sub trackInfoMenu {
+	my ( $client, $url, $track, $remoteMeta ) = @_;
+	
+	return unless $client;
+	
+	# Only show if in the app list
+	return unless $client->isAppEnabled('facebook');
+	
+	my $artist = $track->remote ? $remoteMeta->{artist} : $track->artistName;
+	my $album  = $track->remote ? $remoteMeta->{album}  : ( $track->album ? $track->album->name : undef );
+	my $title  = $track->remote ? $remoteMeta->{title}  : $track->title;
+	
+	my $snURL = '/api/facebook/v1/opml/context';
+	
+	# Search by artist/album/track
+	$snURL .= '?artist=' . uri_escape_utf8($artist)
+		  . '&album='    . uri_escape_utf8($album)
+		  . '&track='    . uri_escape_utf8($title)
+		  . '&upc='      . ( $remoteMeta->{upc} || '' );
+	
+	if ( my $amazon = $remoteMeta->{amazon} ) {
+		$snURL .= '&album_asin='         . $amazon->{album_asin}
+			  . '&album_asin_digital=' . $amazon->{album_asin_digital}
+			  . '&song_asin_digital='  . $amazon->{song_asin_digital};
+	}
+	
+	if ( $artist && ( $album || $title ) ) {
+		return {
+			type      => 'link',
+			name      => $client->string('PLUGIN_FACEBOOK_ON_FACEBOOK'),
+			url       => Slim::Networking::SqueezeNetwork->url($snURL),
+			favorites => 0,
+		};
+	}
+}
+
+### Screensavers
+
+# Each call to a screensaver returns a new image + metadata to display
+# {
+#   image   => 'http://...',
+#   caption => 'text',
+# } 
+
+sub screensaver_news {
+	_screensaver_request( '/api/facebook/v1/screensaver/news', @_ );
+}
+
+sub screensaver_photos { 
+	_screensaver_request( '/api/facebook/v1/screensaver/photos', @_ );
+}
+
+sub _screensaver_request {
+	my $url     = shift;
+	my $request = shift;
+	my $client  = $request->client;
+	
+	$url = Slim::Networking::SqueezeNetwork->url($url);
+	
+	my $http = Slim::Networking::SqueezeNetwork->new(
+		\&_screensaver_ok,
+		\&_screensaver_error,
+		{
+			client  => $client,
+			request => $request,
+			timeout => 35,
+		},
+	);
+	
+	$http->get( $url );
+	
+	$request->setStatusProcessing();
+}
+
+sub _screensaver_ok {
+	my $http    = shift;
+	my $request = $http->params('request');
+	
+	my $data = eval { from_json( $http->content ) };
+	if ( $@ || $data->{error} || !$data->{image} ) {
+		$http->error( $@ || $data->{error} );
+		_screensaver_error( $http );
+		return;
+	}
+	
+	$request->addResult( data => [ $data ] );
+	
+	$request->setStatusDone();
+}
+
+sub _screensaver_error {
+	my $http    = shift;
+	my $error   = $http->error;
+	my $request = $http->params('request');
+	
+	# Not sure what status to use here
+	$request->setStatusBadParams();
+}
+
+1;
diff --git a/Slim/Plugin/Flickr/Plugin.pm b/Slim/Plugin/Flickr/Plugin.pm
index 7056498..7c5bd21 100644
--- a/Slim/Plugin/Flickr/Plugin.pm
+++ b/Slim/Plugin/Flickr/Plugin.pm
@@ -5,7 +5,7 @@ package Slim::Plugin::Flickr::Plugin;
 use strict;
 use base qw(Slim::Plugin::OPMLBased);
 
-use JSON::XS::VersionOneAndTwo;
+use JSON;
 use URI::Escape qw(uri_escape_utf8);
 
 use Slim::Networking::SqueezeNetwork;
diff --git a/Slim/Plugin/ImageBrowser/Plugin.pm b/Slim/Plugin/ImageBrowser/Plugin.pm
index 66cddc9..1cbc3ac 100644
--- a/Slim/Plugin/ImageBrowser/Plugin.pm
+++ b/Slim/Plugin/ImageBrowser/Plugin.pm
@@ -12,7 +12,7 @@ use base qw(Slim::Plugin::OPMLBased);
 use POSIX qw(strftime);
 use Date::Parse qw(strptime);
 use XML::Simple;
-use JSON::XS::VersionOneAndTwo;
+use JSON;
 
 use Slim::Utils::Log;
 use Slim::Utils::Strings qw(string);
diff --git a/Slim/Plugin/LastFM/Plugin.pm b/Slim/Plugin/LastFM/Plugin.pm
index c3cb28f..278732c 100644
--- a/Slim/Plugin/LastFM/Plugin.pm
+++ b/Slim/Plugin/LastFM/Plugin.pm
@@ -14,7 +14,7 @@ use Slim::Utils::Strings qw(cstring);
 use Slim::Utils::Unicode;
 
 use URI::Escape qw(uri_escape_utf8);
-use JSON::XS::VersionOneAndTwo;
+use JSON;
 
 my $log = Slim::Utils::Log->addLogCategory( {
 	category     => 'plugin.lfm',
diff --git a/Slim/Plugin/LastFM/ProtocolHandler.pm b/Slim/Plugin/LastFM/ProtocolHandler.pm
index 225c71a..d7eff5b 100644
--- a/Slim/Plugin/LastFM/ProtocolHandler.pm
+++ b/Slim/Plugin/LastFM/ProtocolHandler.pm
@@ -7,7 +7,7 @@ package Slim::Plugin::LastFM::ProtocolHandler;
 use strict;
 use base qw(Slim::Player::Protocols::HTTP);
 
-use JSON::XS::VersionOneAndTwo;
+use JSON;
 use URI::Escape qw(uri_escape_utf8);
 
 use Slim::Player::Playlist;
diff --git a/Slim/Plugin/Live365/ProtocolHandler.pm b/Slim/Plugin/Live365/ProtocolHandler.pm
index e8119a4..8d36f9a 100644
--- a/Slim/Plugin/Live365/ProtocolHandler.pm
+++ b/Slim/Plugin/Live365/ProtocolHandler.pm
@@ -5,7 +5,7 @@ package Slim::Plugin::Live365::ProtocolHandler;
 use strict;
 use base qw( Slim::Player::Protocols::HTTP );
 
-use JSON::XS::VersionOneAndTwo;
+use JSON;
 use URI::Escape qw(uri_escape);
 
 use Slim::Player::Playlist;
diff --git a/Slim/Plugin/MOG/ProtocolHandler.pm b/Slim/Plugin/MOG/ProtocolHandler.pm
index 31c5612..4e79b57 100644
--- a/Slim/Plugin/MOG/ProtocolHandler.pm
+++ b/Slim/Plugin/MOG/ProtocolHandler.pm
@@ -5,7 +5,7 @@ package Slim::Plugin::MOG::ProtocolHandler;
 use strict;
 use base qw(Slim::Player::Protocols::HTTP);
 
-use JSON::XS::VersionOneAndTwo;
+use JSON;
 use Scalar::Util qw(blessed);
 use URI::Escape qw(uri_escape_utf8);
 
diff --git a/Slim/Plugin/Mediafly/ProtocolHandler.pm b/Slim/Plugin/Mediafly/ProtocolHandler.pm
new file mode 100644
index 0000000..25c605f
--- /dev/null
+++ b/Slim/Plugin/Mediafly/ProtocolHandler.pm
@@ -0,0 +1,468 @@
+package Slim::Plugin::Mediafly::ProtocolHandler;
+
+# $Id$
+
+# Handler for mediafly:// URLs
+
+use strict;
+use base qw(Slim::Player::Protocols::HTTP);
+
+use JSON;
+use URI::Escape qw(uri_escape_utf8);
+
+use Slim::Player::Playlist;
+use Slim::Utils::Misc;
+
+my $log = Slim::Utils::Log->addLogCategory( {
+	category     => 'plugin.mediafly',
+	defaultLevel => 'ERROR',
+	description  => 'PLUGIN_MEDIAFLY_MODULE_NAME',
+} );
+
+# To support remote streaming (synced players, slimp3/SB1), we need to subclass Protocols::HTTP
+sub new {
+	my $class  = shift;
+	my $args   = shift;
+
+	my $client = $args->{client};
+	
+	my $song      = $args->{song};
+	my $streamUrl = $song->streamUrl() || return;
+	my $track     = $song->pluginData();
+	
+	main::DEBUGLOG && $log->is_debug && $log->debug( 'Remote streaming Mediafly track: ' . $streamUrl );
+
+	my $sock = $class->SUPER::new( {
+		url     => $streamUrl,
+		song    => $song,
+		client  => $client,
+		bitrate => $track ? $track->{bitrate} * 1000 : 128_000,
+	} ) || return;
+	
+	${*$sock}{contentType} = 'audio/mpeg';
+
+	return $sock;
+}
+
+sub scanUrl {
+	my ($class, $url, $args) = @_;
+	$args->{cb}->( $args->{song}->currentTrack() );
+}
+
+# Mediafly only gives us MP3 files
+sub getFormatForURL () { 'mp3' }
+
+# Don't allow looping if the tracks are short
+sub shouldLoop () { 0 }
+
+sub canSeek {
+	my ( $class, $client, $song ) = @_;
+	
+	if ( my $track = $song->pluginData() ) {
+		return $track->{canSeek};
+	}
+	
+	return 0;
+}
+
+# XXX: correct seek error
+sub canSeekError { return ( 'SEEK_ERROR_TYPE_NOT_SUPPORTED', 'Mediafly' ); }
+
+sub isRepeatingStream {
+	my ( $class, $song ) = @_;
+	
+	# Channels repeat, individual episodes do not
+	return $song->track()->url =~ m{^mediafly://channel};
+}
+
+sub getNextTrack {
+	my ($class, $song, $successCb, $errorCb) = @_;
+	
+	my $client = $song->master();
+	my $url    = $song->currentTrack()->url;
+	
+	# Get next track
+	my ($slug) = $url =~ m{^mediafly://([^\?]+)};
+	
+	# If first track is specified in the URL, use that once
+	my ($first) = $url =~ m{\?first=(.+)};
+	
+	# If we were playing previously, pass the previous slug
+	my $firstslug = '';
+	my $prevslug = '';
+	
+	my $playedFirst = $client->master->pluginData('playedFirst') || '';
+	
+	if ( $first && $playedFirst ne $first ) {
+		$firstslug = $first;
+	}
+	elsif ( my $track = $song->pluginData() ) {
+		$prevslug = $track->{slug} || $client->master->pluginData('previousSlug');
+	}
+	
+	# Talk to SN and get the next track to play
+	my $trackURL = Slim::Networking::SqueezeNetwork->url(
+		"/api/mediafly/v1/playback/getNextTrack?slug=$slug&prevslug=$prevslug&firstslug=$firstslug"
+	);
+	
+	my $http = Slim::Networking::SqueezeNetwork->new(
+		\&gotNextTrack,
+		\&gotNextTrackError,
+		{
+			client        => $client,
+			song          => $song,
+			playedFirst   => $first,
+			callback      => $successCb,
+			errorCallback => $errorCb,
+			timeout       => 35,
+		},
+	);
+	
+	main::DEBUGLOG && $log->is_debug && $log->debug("Getting next track from SqueezeNetwork for $slug");
+	
+	$http->get( $trackURL );
+}
+
+sub gotNextTrack {
+	my $http   = shift;
+	my $client = $http->params->{client};
+	my $song   = $http->params->{song};	
+	my $url    = $song->currentTrack()->url;
+	my $track  = eval { from_json( $http->content ) };
+	
+	if ( $@ || $track->{error} ) {
+		# We didn't get the next track to play
+		if ( $log->is_warn ) {
+			$log->warn( 'Mediafly error getting next track: ' . ( $@ || $track->{error} ) );
+		}
+		
+		if ( $client->playingSong() ) {
+			$client->playingSong()->pluginData( {
+				songName => $@ || $track->{error},
+			} );
+		}
+		
+		$http->params->{'errorCallback'}->( 'PLUGIN_MEDIAFLY_NO_INFO', $track->{error} );
+		return;
+	}
+	
+	if ( main::DEBUGLOG && $log->is_debug ) {
+		$log->debug( 'Got Mediafly track: ' . Data::Dump::dump($track) );
+	}
+	
+	# If this was a redirect request, change channels
+	if ( my $redir = $track->{redirect} ) {
+		main::DEBUGLOG && $log->is_debug && $log->debug( 'Redirecting to ' . $redir->{url} );
+		
+		$http->params->{errorCallback}->('PLUGIN_MEDIAFLY_CHANGING_CHANNELS');
+		
+		$client->execute( [ 'playlist', 'play', $redir->{url}, $redir->{name} ] );
+		return;
+	}
+	
+	# Save metadata for this track
+	$song->pluginData( $track );
+	$client->master->pluginData( playedFirst => $http->params->{playedFirst} );
+	$client->master->pluginData( previousSlug => $track->{slug} );
+	$song->streamUrl($track->{url});
+
+	$http->params->{callback}->();
+}
+
+sub gotNextTrackError {
+	my $http = shift;
+	
+	$http->params->{errorCallback}->( 'PLUGIN_MEDIAFLY_ERROR', $http->error );
+}
+
+sub parseDirectHeaders {
+	my $class   = shift;
+	my $client  = shift || return;
+	my $url     = shift;
+	my @headers = @_;
+	
+	my $song  = $client->streamingSong();
+	my $track = $song->pluginData(); 
+	
+	my $bitrate     = $track->{bitrate} * 1000;
+	my $contentType = 'mp3';
+	
+	my $length;
+	my $rangelength;
+	
+	# Clear previous duration, since we're using the same URL for all tracks
+	if ( $url =~ /\.rdr$/ ) {
+		Slim::Music::Info::setDuration( $url, 0 );
+	}
+
+	foreach my $header (@headers) {
+		if ( $header =~ /^Content-Length:\s*(.*)/i ) {
+			$length = $1;
+		}
+		elsif ( $header =~ m{^Content-Range: .+/(.*)}i ) {
+			$rangelength = $1;
+			last;
+		}
+	}
+	
+	if ( $rangelength ) {
+		$length = $rangelength;
+	}
+	
+	$client->streamingSong->bitrate($bitrate);
+	$client->streamingSong->duration($track->{secs});
+	
+	# Start a timer to post experience every 30 seconds
+	Slim::Utils::Timers::killTimers( $client, \&postExperience );
+	Slim::Utils::Timers::setTimer(
+		$client,
+		Time::HiRes::time() + 30,
+		\&postExperience,
+		$track->{slug},
+	);
+	
+	# title, bitrate, metaint, redir, type, length, body
+	return (undef, $bitrate, 0, undef, $contentType, $length, undef);
+}
+
+# If an audio stream fails, keep playing
+sub handleDirectError {
+	my ( $class, $client, $url, $response, $status_line ) = @_;
+	
+	main::INFOLOG && $log->info("Direct stream failed: $url [$response] $status_line");
+	
+	$client->controller()->playerStreamingFailed( $client, 'PLUGIN_MEDIAFLY_STREAM_FAILED' );
+}
+
+sub canDirectStreamSong {
+	my ( $class, $client, $song ) = @_;
+	
+	# We need to check with the base class (HTTP) to see if we
+	# are synced or if the user has set mp3StreamingMethod
+	return $class->SUPER::canDirectStream( $client, $song->streamUrl(), $class->getFormatForURL() );
+}
+
+# Track Info menu
+sub trackInfo {
+	my ( $class, $client, $track ) = @_;
+	
+	my $url = $track->url;
+
+	# SN URL to fetch track info menu
+	my $trackInfoURL = $class->trackInfoURL( $client, $url );
+	
+	# let XMLBrowser handle all our display
+	my %params = (
+		header   => 'PLUGIN_MEDIAFLY_GETTING_TRACK_DETAILS',
+		modeName => 'Mediafly Now Playing',
+		title    => Slim::Music::Info::getCurrentTitle( $client, $url ),
+		url      => $trackInfoURL,
+		remember => 0,
+		timeout  => 35,
+	);
+
+	Slim::Buttons::Common::pushMode( $client, 'xmlbrowser', \%params );
+	
+	$client->modeParam( 'handledTransition', 1 );
+}
+
+# URL used for CLI trackinfo queries
+sub trackInfoURL {
+	my ( $class, $client, $url ) = @_;
+	
+	# Get the current track
+	my $currentTrack = $client->currentSongForUrl($url)->pluginData();
+	
+	my $episode     = $currentTrack->{slug};
+	my $channelSlug = $currentTrack->{channelSlug};
+	my $channelName = $currentTrack->{channel};
+	
+	# SN URL to fetch track info menu
+	my $trackInfoURL = Slim::Networking::SqueezeNetwork->url(
+		  '/api/mediafly/v1/opml/trackinfo?episode=' . $episode
+		. '&channelSlug=' . $channelSlug 
+		. '&channelName=' . uri_escape_utf8($channelName)
+	);
+	
+	return $trackInfoURL;
+}
+
+# Metadata for a URL, used by CLI/JSON clients
+sub getMetadataFor {
+	my ( $class, $client, $url, $forceCurrent ) = @_;
+	
+	my $song = $forceCurrent ? $client->streamingSong() : $client->playingSong();
+	return {} unless $song;
+	
+	# In episode mode, other tracks on the playlist don't return metadata
+	if ( $song->currentTrack()->url ne $url ) {
+		return {};
+	}
+	
+	my $icon = $class->getIcon();
+	
+	if ( my $track = $song->pluginData() ) {
+		
+		my $date = '';
+		($date) = $track->{published} =~ m/^(\d{4}-\d{2}-\d{2})/ if $track->{published};
+		
+		# bug 15499 - wipe track object's title, it's initially set by Slim::Control::Queries::_songData only
+		$song->track->title('') if $song->track->title();
+
+		return {
+			artist      => $track->{show}->[0]->{title} || $track->{showTitle},
+			title       => $track->{title},
+			album       => $date,
+			cover       => $track->{imageUrl},
+			icon        => $icon,
+			duration    => $track->{secs},
+			bitrate     => ( $track->{bitrate} ) ? $track->{bitrate} . 'k' : undef,
+			type        => 'Mediafly',
+			info_link   => 'plugins/mediafly/trackinfo.html',
+			buttons       => {
+				fwd => 1,
+				rew => 1,
+			},
+		};
+	}
+	else {
+		return {
+			icon  => $icon,
+			cover => $icon,
+			type  => 'Mediafly',
+		};
+	}
+}
+
+sub getIcon {
+	my ( $class, $url ) = @_;
+
+	return Slim::Plugin::Mediafly::Plugin->_pluginDataFor('icon');
+}
+
+# XXX: this is called more than just when we stop
+sub onStop {
+	my ($class, $song) = @_;
+	
+	main::DEBUGLOG && $log->is_debug && $log->debug("onStop, posting experience");
+	
+	postExperience( $song->master(), $song->pluginData()->{slug} );
+}
+
+sub onPlayout {
+	my ($class, $song) = @_;
+	
+	main::DEBUGLOG && $log->is_debug && $log->debug("onPlayout, posting experience");
+	
+	postExperience( $song->master(), $song->pluginData()->{slug}, 1 );
+}
+
+sub postExperience {
+	my ( $client, $slug, $end ) = @_;
+	
+	my $song  = $client->playingSong() || return;
+	my $track = $song->pluginData();
+	
+	# Make sure we haven't changed tracks
+	if ( !$track || !$slug || $track->{slug} ne $slug ) {
+		main::DEBUGLOG && $log->is_debug && $log->debug( "Not posting experience for $slug, no longer playing" );
+		return;
+	}
+	
+	my $time = Slim::Player::Source::songTime( $song->master() );
+	
+	$time = int($time);
+	
+	my $length = $track->{secs};
+	
+	# If at end, set time == length
+	if ( $end ) {
+		$time = $length;
+	}
+	
+	# Make sure time is not 0, that means we've stopped
+	return if $time == 0;
+	
+	my $logURL = Slim::Networking::SqueezeNetwork->url(
+		"/api/mediafly/v1/playback/postExperience?slug=$slug&position=$time&length=$length"
+	);
+
+	my $http = Slim::Networking::SqueezeNetwork->new(
+		sub {
+			if ( main::DEBUGLOG && $log->is_debug ) {
+				my $http = shift;
+				$log->debug( "Post experience returned: " . $http->content );
+			}
+		},
+		sub {
+			if ( main::DEBUGLOG && $log->is_debug ) {
+				my $http = shift;
+				$log->debug( "Post experience returned error: " . $http->error );
+			}
+		},
+		{
+			client => $song->master(),
+		},
+	);
+
+	main::DEBUGLOG && $log->debug("Posting experience: $time/$length seconds for $slug");
+
+	$http->get( $logURL );
+	
+	# Post again in 30 seconds unless we're done
+	if ( !$end ) {
+		main::DEBUGLOG && $log->is_debug && $log->debug( "Will post experience for $slug again in 30 seconds" );
+		
+		Slim::Utils::Timers::killTimers( $client, \&postExperience );
+		Slim::Utils::Timers::setTimer(
+			$client,
+			Time::HiRes::time() + 30,
+			\&postExperience,
+			$slug,
+		);
+	}
+}
+
+# SN only
+# Re-init Mediafly when a player reconnects
+sub reinit {
+	my ( $class, $client, $song ) = @_;
+
+	my $url = $song->currentTrack->url();
+	
+	main::DEBUGLOG && $log->debug("Re-init Mediafly - $url");
+
+	if ( my $track = $song->pluginData() ) {
+		# We have previous data about the currently-playing song
+		
+		# Back to Now Playing
+		Slim::Buttons::Common::pushMode( $client, 'playlist' );
+		
+		# Reset song duration/progress bar
+		if ( $track->{secs} ) {
+			# On a timer because $client->currentsongqueue does not exist yet
+			Slim::Utils::Timers::setTimer(
+				$client,
+				Time::HiRes::time(),
+				sub {
+					my $client = shift;
+					
+					$client->streamingProgressBar( {
+						url      => $url,
+						duration => $track->{secs},
+					} );
+				},
+			);
+		}
+	}
+	else {
+		# No data, just restart the current station
+		main::DEBUGLOG && $log->debug("No data about playing track, restarting station");
+
+		$client->execute( [ 'playlist', 'play', $url ] );
+	}
+	
+	return 1;
+}
+
+1;
diff --git a/Slim/Plugin/Orange/Metadata.pm b/Slim/Plugin/Orange/Metadata.pm
index 1b36e4d..10d0889 100644
--- a/Slim/Plugin/Orange/Metadata.pm
+++ b/Slim/Plugin/Orange/Metadata.pm
@@ -8,7 +8,7 @@ use URI::Escape qw(uri_escape_utf8);
 use URI::Split qw(uri_split);
 
 use Slim::Formats::RemoteMetadata;
-use JSON::XS::VersionOneAndTwo;
+use JSON;
 use Slim::Music::Info;
 use Slim::Networking::SimpleAsyncHTTP;
 use Slim::Utils::Log;
diff --git a/Slim/Plugin/Pandora/ProtocolHandler.pm b/Slim/Plugin/Pandora/ProtocolHandler.pm
index 68a306b..5fe23ac 100644
--- a/Slim/Plugin/Pandora/ProtocolHandler.pm
+++ b/Slim/Plugin/Pandora/ProtocolHandler.pm
@@ -7,7 +7,7 @@ package Slim::Plugin::Pandora::ProtocolHandler;
 use strict;
 use base qw(Slim::Player::Protocols::HTTP);
 
-use JSON::XS::VersionOneAndTwo;
+use JSON;
 
 use Slim::Player::Playlist;
 use Slim::Utils::Misc;
diff --git a/Slim/Plugin/RhapsodyDirect/ProtocolHandler.pm b/Slim/Plugin/RhapsodyDirect/ProtocolHandler.pm
index 11faa7f..0d4011f 100644
--- a/Slim/Plugin/RhapsodyDirect/ProtocolHandler.pm
+++ b/Slim/Plugin/RhapsodyDirect/ProtocolHandler.pm
@@ -8,7 +8,7 @@ use strict;
 use base qw(Slim::Player::Protocols::HTTP);
 
 use HTML::Entities qw(encode_entities);
-use JSON::XS::VersionOneAndTwo;
+use JSON;
 use MIME::Base64 qw(decode_base64);
 use Scalar::Util qw(blessed);
 use URI::Escape qw(uri_escape_utf8);
diff --git a/Slim/Plugin/SN/ProtocolHandler.pm b/Slim/Plugin/SN/ProtocolHandler.pm
index e522a42..cb9683d 100644
--- a/Slim/Plugin/SN/ProtocolHandler.pm
+++ b/Slim/Plugin/SN/ProtocolHandler.pm
@@ -16,7 +16,7 @@ use strict;
 
 use Time::HiRes;
 
-use JSON::XS::VersionOneAndTwo;
+use JSON;
 use Slim::Utils::Timers;
 use Slim::Utils::Log;
 
diff --git a/Slim/Plugin/Sirius/ProtocolHandler.pm b/Slim/Plugin/Sirius/ProtocolHandler.pm
index d25c2f3..3cef6e7 100644
--- a/Slim/Plugin/Sirius/ProtocolHandler.pm
+++ b/Slim/Plugin/Sirius/ProtocolHandler.pm
@@ -19,7 +19,7 @@ use Slim::Utils::Misc;
 use Slim::Utils::Timers;
 
 use HTTP::Request;
-use JSON::XS::VersionOneAndTwo;
+use JSON;
 use URI::Escape qw(uri_escape);
 
 my $log = Slim::Utils::Log->addLogCategory( {
diff --git a/Slim/Plugin/Slacker/ProtocolHandler.pm b/Slim/Plugin/Slacker/ProtocolHandler.pm
index 13311c0..cc779b6 100644
--- a/Slim/Plugin/Slacker/ProtocolHandler.pm
+++ b/Slim/Plugin/Slacker/ProtocolHandler.pm
@@ -9,7 +9,7 @@ use Slim::Music::Info;
 use Slim::Utils::Misc;
 use Slim::Utils::Timers;
 
-use JSON::XS::VersionOneAndTwo;
+use JSON;
 
 my $log = Slim::Utils::Log->addLogCategory( {
 	category     => 'plugin.slacker',
diff --git a/Slim/Plugin/SpotifyLogi/ProtocolHandler.pm b/Slim/Plugin/SpotifyLogi/ProtocolHandler.pm
index 2be8871..bb605af 100644
--- a/Slim/Plugin/SpotifyLogi/ProtocolHandler.pm
+++ b/Slim/Plugin/SpotifyLogi/ProtocolHandler.pm
@@ -5,7 +5,7 @@ package Slim::Plugin::SpotifyLogi::ProtocolHandler;
 use strict;
 use base qw(Slim::Player::Protocols::SqueezePlayDirect);
 
-use JSON::XS::VersionOneAndTwo;
+use JSON;
 use MIME::Base64 qw(decode_base64);
 use Scalar::Util qw(blessed);
 use URI::Escape qw(uri_escape);
diff --git a/Slim/Plugin/WiMP/ProtocolHandler.pm b/Slim/Plugin/WiMP/ProtocolHandler.pm
index c0ed183..52870a6 100644
--- a/Slim/Plugin/WiMP/ProtocolHandler.pm
+++ b/Slim/Plugin/WiMP/ProtocolHandler.pm
@@ -5,7 +5,7 @@ package Slim::Plugin::WiMP::ProtocolHandler;
 use strict;
 use base qw(Slim::Player::Protocols::HTTP);
 
-use JSON::XS::VersionOneAndTwo;
+use JSON;
 use URI::Escape qw(uri_escape_utf8);
 use Scalar::Util qw(blessed);
 
diff --git a/Slim/Schema/TrackPersistent.pm b/Slim/Schema/TrackPersistent.pm
index b81f8e5..a3be23d 100644
--- a/Slim/Schema/TrackPersistent.pm
+++ b/Slim/Schema/TrackPersistent.pm
@@ -6,7 +6,7 @@ use strict;
 use base 'Slim::Schema::DBI';
 
 use File::Slurp qw(read_file);
-use JSON::XS::VersionOneAndTwo;
+use JSON;
 use Scalar::Util qw(blessed);
 
 use Slim::Utils::DateTime;
diff --git a/Slim/Utils/Prefs/Base.pm b/Slim/Utils/Prefs/Base.pm
index 1f704da..682fbf6 100644
--- a/Slim/Utils/Prefs/Base.pm
+++ b/Slim/Utils/Prefs/Base.pm
@@ -20,7 +20,7 @@ Base class for preference objects implementing methods which can be used on glob
 
 use strict;
 
-use JSON::XS::VersionOneAndTwo;
+use JSON;
 use Scalar::Util qw(blessed);
 use Storable;
 
diff --git a/Slim/Utils/Progress.pm b/Slim/Utils/Progress.pm
index 2e8fc4e..aea8995 100644
--- a/Slim/Utils/Progress.pm
+++ b/Slim/Utils/Progress.pm
@@ -9,7 +9,7 @@ package Slim::Utils::Progress;
 use strict;
 use base qw(Slim::Utils::Accessor);
 
-use JSON::XS::VersionOneAndTwo;
+use JSON;
 
 use Slim::Schema;
 use Slim::Utils::Unicode;
diff --git a/Slim/Utils/SQLiteHelper.pm b/Slim/Utils/SQLiteHelper.pm
index 1c641b6..b62d835 100644
--- a/Slim/Utils/SQLiteHelper.pm
+++ b/Slim/Utils/SQLiteHelper.pm
@@ -25,7 +25,7 @@ use File::Basename;
 use File::Path;
 use File::Slurp;
 use File::Spec::Functions qw(:ALL);
-use JSON::XS::VersionOneAndTwo;
+use JSON;
 use Time::HiRes qw(sleep);
 
 use Slim::Utils::ArtworkCache;
diff --git a/Slim/Utils/Strings.pm b/Slim/Utils/Strings.pm
index 54cb024..768e381 100644
--- a/Slim/Utils/Strings.pm
+++ b/Slim/Utils/Strings.pm
@@ -45,7 +45,7 @@ use Digest::SHA qw(sha1_hex);
 use POSIX qw(setlocale LC_TIME LC_COLLATE);
 use File::Slurp qw(read_file write_file);
 use File::Spec::Functions qw(:ALL);
-use JSON::XS::VersionOneAndTwo;
+use JSON;
 use Scalar::Util qw(blessed);
 use Storable;
 
diff --git a/Slim/Web/Cometd.pm b/Slim/Web/Cometd.pm
index b9398ad..91cae24 100644
--- a/Slim/Web/Cometd.pm
+++ b/Slim/Web/Cometd.pm
@@ -20,7 +20,7 @@ use strict;
 
 use bytes;
 use HTTP::Date;
-use JSON::XS::VersionOneAndTwo;
+use JSON;
 use Scalar::Util qw(blessed);
 use URI::Escape qw(uri_unescape);
 
diff --git a/Slim/Web/JSONRPC.pm b/Slim/Web/JSONRPC.pm
index 0b855a5..7017c7f 100644
--- a/Slim/Web/JSONRPC.pm
+++ b/Slim/Web/JSONRPC.pm
@@ -13,7 +13,7 @@ package Slim::Web::JSONRPC;
 use strict;
 
 use HTTP::Status qw(RC_OK);
-use JSON::XS::VersionOneAndTwo;
+use JSON;
 use Scalar::Util qw(blessed);
 
 use Slim::Web::HTTP;
